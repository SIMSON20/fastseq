# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['show_graph', 'show_xy_graph', 'show_xyy_graph', 'test_graph_exists', 'show_graphs', 'TensorSeq',
           'show_graph_batch', 'skip', 'ts_lists', 'ToElapsed', 'make_interval', 'melted_ts_2_lists']

# Cell
from fastcore.all import *
from fastai2.basics import *
import pandas as pd

# Cell

def _no_emp_dim(x):
    if x.shape[0]==1 and len(x.shape)>1:
        x=x[0,:]
    return x

def show_graph(array, ax=None, figsize=None, title=None, ctx=None, y=None, tx=None, ty=None, y_hat=None, **kwargs):
    "Show an array on `ax`."
    # Handle pytorch axis order
    if hasattrs(array, ('data','cpu','permute')):
        array = array.data.cpu()
    elif not isinstance(array,np.ndarray):
        array=array(array)
    ax = ifnone(ax,ctx)
    if figsize is None: figsize = (5,5)
    if ax is None: _,ax = plt.subplots(figsize=figsize)
    array =  _no_emp_dim(array)
    tx = ifnone(tx,np.arange(len(array)))
    ax.plot(tx, array, '-*b', **kwargs)
    if y is not None or y_hat is not None:
        y = _no_emp_dim(y)
        ty = ifnone(ty,np.arange(len(array),len(array)+len(y)))
        if y is not None:
            ax.plot(ty, y,'-*g' ,label='target', **kwargs)
        if y_hat is not None:
            y_hat = _no_emp_dim(y_hat)
            ax.plot(ty, y_hat,'*r',label='pred', **kwargs)

    if title is not None: ax.set_title(title)
#     ax.axis('off')
    return ax

# Cell
def show_xy_graph(o, **kwargs):
    "Call `show_graph` destructuring `o` to `(array,y)`"
    show_graph(o[0], y=o[1], **kwargs)

# Cell
def show_xyy_graph(o, **kwargs):
    "Call `show_graph` destructuring `o` to `(array,y,y_hat)`"
    show_graph(o[0], y=o[1], y_hat=o[2], **kwargs)

# Cell
def test_graph_exists(ax):
    "Test there is a graph displayed in `ax`"
    assert ax

# Cell
@delegates(subplots)
def show_graphs(arrays, rows=1, titles=None, **kwargs):
    "Show all images `arrays` as subplots with `rows` using `titles`"
    cols = int(math.ceil(len(arrays)/rows))
    if titles is None: titles = [None]*len(arrays)
    axs = subplots(rows,cols,**kwargs)[1].flat
    for a,t,ax in zip(arrays, titles, axs):
        show_xy_graph(a, ax=ax, title=t)

# Cell
class TensorSeq(TensorBase):
    def show(self, ctx=None, **kwargs):
        return show_graph(self, ctx=ctx, **kwargs)

# Cell
def show_graph_batch(b, show=show_titled_image, items=9, cols=3, figsize=None, **kwargs):
    "Display batch `b` in a grid of size `items` with `cols` width"
    if items<cols: cols=items
    rows = (items+cols-1) // cols
    if figsize is None: figsize = (cols*3, rows*3)
    fig,axs = plt.subplots(rows, cols, figsize=figsize)
    for *o,ax in zip(*to_cpu(b), axs.flatten()):
        show_xy_graph(o, ax=ax, **kwargs)

# Cell
def skip(x,percentage = .9):
    if (np.random.rand() > percentage or x == 0):
        return False
    return True


# Cell
def ts_lists(ts:np.ndarray)-> L:
    """Transforms a `np.ndarray` of shape (timeseries, max_time) to a list of timeseries with shape (1,time).

    where:

    max_time = the length of the longest timeserie

    time = the length of the non-nan values of that specific timeserie
    """
    lst = L()
    for time_series in ts:
        lst.append(time_series[~np.isnan(time_series)][None,:])
    return lst

# Cell
class ToElapsed():
    changed = False
    def __call__(self, s):
        if pd.api.types.is_datetime64_any_dtype(s.dtype):
            self.changed = True
            return s.astype(np.int64) // 10 ** 9
        return s

    def decode(self, s):
        if self.changed:
            return pd.Series(pd.to_datetime(s *(10 ** 9)))
        return s


# Cell
def make_interval(
    df: pd.DataFrame,
    to_split_col:str='datetime',
    interval=3600,
    max_splits=100000,
    callback_error=None,
) -> L(pd.DataFrame):
    """Will check if column `to_split_col` in `df` has interval size of `interval`,
    if not will make it happen and return a list where this is done.

    This works both when type of `to_split_col` is numeric or `pd.Timestamp`

    """
    tmf = ToElapsed()
    df[to_split_col] = tmf(df[to_split_col])
    df.index = df[to_split_col]
    df = df.sort_index()
    index = df.index.to_numpy()
    df["delta"] = abs(
        (df[to_split_col] - df[to_split_col].shift(1))
    )
    mask = df["delta"] != interval
    starts = np.arange(len(mask))[mask]
    ends = list(starts[1:])+L(len(mask))

    del df["delta"]

    if len(ends) > max_splits:
        if callback_error:
            callback_error()
        raise Exception(
            f"number of splits {len(not_hour)} > {max_splits}: \n{not_hour}"
        )
#     print(starts,ends)
    dfs = L()
    for start, end in zip(starts, ends):
        _df = df.iloc[start: end,:]
        _df.loc[:,to_split_col] = tmf.decode(_df[to_split_col])
        dfs.append(_df)

    return dfs

# Cell
def melted_ts_2_lists(ts:pd.DataFrame, melted_col_name:str, fn=noop, **kwargs)->L:
    dfs = L()
    for c in set(ts[melted_col_name]):
        _df = ts[ts[melted_col_name] == c]
        r = fn(_df,**kwargs)
        dfs += r
    return dfs