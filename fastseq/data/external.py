# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_data.external.ipynb (unless otherwise specified).

__all__ = ['m4_base', 'dummy_data_generator', 'dummy_data_generator_multi', 'same_size_ts']

# Cell
from ..core import *
from fastcore.utils import *
from fastcore.imports import *
from fastai2.basics import *
import pandas as pd

# Cell
m4_base = "https://motionnet-m4-dataset.s3.eu-central-1.amazonaws.com/"
URLs.m4_daily = f'{m4_base}m4_daily.tgz'

# Cell
def dummy_data_generator(lookback:int, horizon:int, signal_type='seasonality', nrows:int=5, random = True, batch_size=32, norm=False, noise = .2):
    def get_datapoint():
        lin_space = np.linspace(-lookback, horizon, lookback + horizon)
        if random:
            offset = np.random.standard_normal() * .10
        else:
            offset = 1
        if signal_type == 'lin':
            a =  np.random.standard_normal() * lin_space + offset * 100

        a = np.zeros_like(lin_space)
        if signal_type is not 'seasonality':
            p = 4
            a = [(lin_space**(i))[None,:] for i in range(p)]
            T = np.concatenate(a)
            thetas = np.random.randn(4)*1*9**-p
            a= np.matmul(thetas,T)

        if signal_type is not 'trend':
            a += np.cos(2 * np.random.randint(low=1, high=3) * np.pi * lin_space)* np.random.standard_normal() * .5
            a += np.cos(2 * np.random.randint(low=2, high=4) * np.pi * lin_space)* np.random.standard_normal() * .5
            a += np.sin(2 * np.random.randint(low=1, high=3) * np.pi * lin_space)
            a -= np.sin(2 * np.random.randint(low=2, high=4) * np.pi * lin_space)
            a += lin_space * offset + np.random.rand() * 10

        a += np.random.randn(a.shape[0])*noise
        if norm:
            return (a[None,:]-a.mean())/a.std()
        else:
            return a[None,:]

    data = L()
    for i in range(nrows):
        data.append(get_datapoint())

    return data


# Cell

def dummy_data_generator_multi(length, citys=2, cont = False, signal_type='none',nrows:int=5, random = True, noise = .2, incl_city_trend = False, norm= True, increase_noise = False):

    data = L()
    for city_i in range(citys):
        city_trend = 2* dummy_data_generator(length, 0, signal_type = 'trend', nrows=1, random=random, noise = 0 )[0]
        for i in range(nrows):
            weather = dummy_data_generator(length-10, 10, signal_type = 'seasonality', nrows=1, random=random, noise = 0 )[0]
            cont = np.random.randn()
            if cont:
                city_weather = cont * city_trend + weather
            else:
                city_weather = city_trend + weather
            normal_signal = 3 * dummy_data_generator(length//2, length//2, signal_type = signal_type, nrows=1, random=random, noise = noise )[0]
            if increase_noise:
                city_weather += dummy_data_generator(2, length-2, signal_type = 'seasonality', nrows=1, random=random, noise = noise,norm=True )[0] * (np.random.randn(length) *(np.arange(length) * (1/length) ) * noise)
            final = normal_signal + city_weather * (1+np.random.randn(length) * .1 * noise)
            tot = [final, weather]
            if incl_city_trend:
                tot.append(city_trend)
            r = np.concatenate(tot)
            if norm:
                r = (r-r.mean())/r.std()
            if cont:
                data.append((r, city_i, cont))
            else:
                data.append((r, city_i))


    return data


# Cell
from typing import List
def same_size_ts(ts:pd.Series, ts_names:List[str]):
    all_same = [[(ts[c].shape == ts[a].shape) for c in ts_names] for a in ts_names]
    mask = np.array(all_same)
    return np.sum(mask) == len(ts_names)**2
